{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Configuration",
        "description": "Initialize the project repository with Node.js backend and Vue.js frontend structure",
        "details": "Create a new project with the following structure:\n1. Backend: Express.js server with TypeScript\n2. Frontend: Vue 3 with Vite and Composition API\n\nSetup package.json with required dependencies:\n```json\n// Backend dependencies\n{\n  \"express\": \"^4.18.0\",\n  \"cors\": \"^2.8.5\",\n  \"dotenv\": \"^16.0.0\",\n  \"jsonwebtoken\": \"^9.0.0\",\n  \"express-session\": \"^1.17.0\",\n  \"winston\": \"^3.8.0\"\n}\n\n// Frontend dependencies\n{\n  \"vue\": \"^3.3.0\",\n  \"vue-router\": \"^4.2.0\",\n  \"pinia\": \"^2.1.0\",\n  \"axios\": \"^1.4.0\",\n  \"vuetify\": \"^3.3.0\"\n}\n```\n\nConfigure ESLint and Prettier for code formatting. Set up environment variables with .env files for both backend and frontend. Initialize Git repository with appropriate .gitignore file.",
        "testStrategy": "Verify project structure is correctly set up. Ensure all dependencies can be installed without errors. Test that the development server can be started for both backend and frontend. Validate ESLint and Prettier configurations work correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Google OAuth2 Authentication Implementation",
        "description": "Implement Google OAuth2 authentication for connecting to Google Sheets",
        "details": "Use the googleapis library to implement OAuth2 authentication flow:\n\n```javascript\nconst { google } = require('googleapis');\n\n// Create OAuth2 client\nconst oauth2Client = new google.auth.OAuth2(\n  process.env.GOOGLE_CLIENT_ID,\n  process.env.GOOGLE_CLIENT_SECRET,\n  process.env.GOOGLE_REDIRECT_URI\n);\n\n// Generate authentication URL\nconst authUrl = oauth2Client.generateAuthUrl({\n  access_type: 'offline',\n  scope: ['https://www.googleapis.com/auth/spreadsheets']\n});\n\n// Handle callback and token exchange\nasync function handleCallback(code) {\n  const { tokens } = await oauth2Client.getToken(code);\n  oauth2Client.setCredentials(tokens);\n  // Store tokens securely\n  return tokens;\n}\n```\n\nCreate API endpoints for initiating OAuth flow and handling callbacks. Implement secure token storage using express-session or similar mechanism. Add refresh token handling for maintaining long-term access.",
        "testStrategy": "Test OAuth2 flow by initiating authentication and verifying token retrieval. Validate token refresh mechanism works correctly. Ensure error handling for failed authentication attempts. Test with mock Google responses for various scenarios.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Google Sheets API Integration",
        "description": "Implement Google Sheets API integration for reading and writing delivery data",
        "details": "Use the Google Sheets API v4 to interact with spreadsheets:\n\n```javascript\nasync function getSheetData(spreadsheetId, sheetName) {\n  const sheets = google.sheets({ version: 'v4', auth: oauth2Client });\n  const range = `${sheetName}!A:D`;\n  \n  const response = await sheets.spreadsheets.values.get({\n    spreadsheetId,\n    range,\n  });\n  \n  return response.data.values;\n}\n\nasync function updateSheetData(spreadsheetId, sheetName, row, column, value) {\n  const sheets = google.sheets({ version: 'v4', auth: oauth2Client });\n  const range = `${sheetName}!${column}${row}`;\n  \n  await sheets.spreadsheets.values.update({\n    spreadsheetId,\n    range,\n    valueInputOption: 'USER_ENTERED',\n    resource: {\n      values: [[value]]\n    }\n  });\n}\n```\n\nImplement functions for:\n1. Listing available spreadsheets\n2. Creating new sheets for delivery staff\n3. Reading delivery data from specific sheets\n4. Updating delivery status in the D column\n5. Setting up real-time synchronization using polling",
        "testStrategy": "Test sheet reading and writing with a test spreadsheet. Verify correct handling of sheet creation and modification. Test error handling for API limits and permission issues. Validate real-time synchronization works within performance requirements (30 orders synced within 10 seconds).",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Admin Settings Page UI",
        "description": "Create the admin settings page for Google Sheets and SOLAPI integration with delivery staff management",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "Develop a Vue.js component for the admin settings page with the following features:\n\n1. Delivery Staff Management Section:\n   - Form to register new delivery staff (name, contact information)\n   - List of registered delivery staff with edit/delete options\n   - Automatic QR code generation for each staff member\n   - Download functionality for QR codes (individual or batch)\n\n2. Date-based Spreadsheet Management:\n   - Interface to connect spreadsheets by date\n   - URL input field for Google Sheets with automatic mapping\n   - Calendar view to select dates and assign spreadsheets\n   - Status indicator showing connection state for each date\n\n3. Google Sheets Connection Section:\n```vue\n<template>\n  <v-card>\n    <v-card-title>Google Sheets Connection</v-card-title>\n    <v-card-text>\n      <div v-if=\"!isConnected\">\n        <v-btn color=\"primary\" @click=\"connectGoogleSheets\">\n          Connect Google Sheets\n        </v-btn>\n      </div>\n      <div v-else>\n        <div class=\"connection-status\">\n          <v-icon color=\"green\">mdi-check-circle</v-icon>\n          Connected to: {{ spreadsheetName }}\n        </div>\n        <v-btn text @click=\"disconnectGoogleSheets\">Disconnect</v-btn>\n        <v-btn text @click=\"connectDifferentSheet\">Connect Different Sheet</v-btn>\n      </div>\n    </v-card-text>\n  </v-card>\n</template>\n```\n\n4. SOLAPI Connection Section:\n   - Connection status display\n   - Authentication button for SOLAPI integration\n   - Test message functionality\n\n5. QR Code System:\n   - Preview of generated QR codes\n   - Explanation that QR codes will automatically load the correct day's work when scanned\n\nImplement the necessary Pinia store for managing connection states, delivery staff data, and API interactions.",
        "testStrategy": "Test UI rendering and responsive design on different screen sizes. Verify all buttons trigger the correct actions. Test connection status updates correctly based on API responses. Validate form validation for required fields. Test with mock API responses for various scenarios. Specifically test:\n\n1. Delivery staff registration and QR code generation\n2. Date-based spreadsheet connection workflow\n3. QR code download functionality\n4. Spreadsheet status verification\n5. Error handling for invalid spreadsheet URLs\n6. Mobile responsiveness of the entire admin interface",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Delivery Staff Management UI",
            "description": "Create the UI components for registering and managing delivery staff",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement QR Code Generation System",
            "description": "Create functionality to automatically generate and download QR codes for each delivery staff",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Date-based Spreadsheet Connection UI",
            "description": "Create UI for connecting different spreadsheets by date with URL input and automatic mapping",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Google Sheets Connection Status Component",
            "description": "Create component to display and manage connection status for spreadsheets",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement SOLAPI Integration UI",
            "description": "Create the UI for SOLAPI connection and configuration",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create Pinia Store for Admin Settings",
            "description": "Implement store to manage delivery staff data, spreadsheet connections, and API states",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "SOLAPI OAuth2 Integration",
        "description": "Implement SOLAPI OAuth2 authentication for message sending capabilities",
        "details": "Implement SOLAPI OAuth2 authentication flow:\n\n```javascript\n// Generate SOLAPI OAuth URL\nfunction generateSolapiAuthUrl() {\n  const clientId = process.env.SOLAPI_CLIENT_ID;\n  const redirectUri = process.env.SOLAPI_REDIRECT_URI;\n  const scope = 'message:write cash:read senderid:read kakao:write kakao:read';\n  \n  return `https://api.solapi.com/oauth2/authorize?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&scope=${encodeURIComponent(scope)}&response_type=code`;\n}\n\n// Handle callback and token exchange\nasync function handleSolapiCallback(code) {\n  const clientId = process.env.SOLAPI_CLIENT_ID;\n  const clientSecret = process.env.SOLAPI_CLIENT_SECRET;\n  const redirectUri = process.env.SOLAPI_REDIRECT_URI;\n  \n  const response = await axios.post('https://api.solapi.com/oauth2/token', {\n    grant_type: 'authorization_code',\n    code,\n    client_id: clientId,\n    client_secret: clientSecret,\n    redirect_uri: redirectUri\n  });\n  \n  return response.data;\n}\n```\n\nImplement API endpoints for:\n1. Initiating SOLAPI OAuth flow\n2. Handling callbacks and token exchange\n3. Refreshing tokens when expired\n4. Retrieving account information and sender IDs\n5. Fetching and managing message templates",
        "testStrategy": "Test OAuth2 flow with SOLAPI by initiating authentication and verifying token retrieval. Validate token refresh mechanism works correctly. Test error handling for failed authentication attempts. Verify sender ID retrieval and template management functions work as expected.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "QR Code Generation System",
        "description": "Implement QR code generation for delivery staff authentication",
        "details": "Use the qrcode library to generate QR codes for delivery staff:\n\n```javascript\nconst qrcode = require('qrcode');\nconst jwt = require('jsonwebtoken');\n\n// Generate token for staff\nfunction generateStaffToken(staffName) {\n  const secretKey = process.env.JWT_SECRET;\n  const token = jwt.sign(\n    { staff: staffName, date: new Date().toISOString().split('T')[0] },\n    secretKey,\n    { expiresIn: '7d' }\n  );\n  return token;\n}\n\n// Generate QR code URL\nfunction generateStaffQrUrl(staffName) {\n  const token = generateStaffToken(staffName);\n  const baseUrl = process.env.APP_URL;\n  return `${baseUrl}/delivery?staff=${encodeURIComponent(staffName)}&token=${token}`;\n}\n\n// Generate QR code as data URL\nasync function generateStaffQrCode(staffName) {\n  const url = generateStaffQrUrl(staffName);\n  return await qrcode.toDataURL(url);\n}\n```\n\nImplement API endpoints for:\n1. Generating QR codes for specific staff members\n2. Verifying QR code tokens\n3. Validating staff name matches with token\n\nCreate a Vue component for displaying and downloading QR codes in the admin interface.",
        "testStrategy": "Test QR code generation with various staff names. Verify QR codes contain the correct URL format. Test token validation with valid and invalid tokens. Ensure QR codes can be properly scanned by mobile devices. Test the name verification process works correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Delivery Staff Authentication System",
        "description": "Implement the automated authentication system for delivery staff",
        "status": "done",
        "dependencies": [
          6
        ],
        "priority": "high",
        "details": "Create an automated authentication system using QR code scanning:\n\n1. QR code contains delivery staff information and work date\n2. After scanning, automatically fetch assigned orders from the spreadsheet for that date\n3. Display appropriate error UI for various scenarios\n\n```javascript\n// Verify staff token from QR code\nfunction verifyStaffToken(token) {\n  try {\n    const secretKey = process.env.JWT_SECRET;\n    const decoded = jwt.verify(token, secretKey);\n    return {\n      staffName: decoded.staff,\n      workDate: decoded.workDate,\n      valid: true\n    };\n  } catch (error) {\n    return { valid: false };\n  }\n}\n\n// API endpoint for staff authentication\napp.post('/api/delivery/auth', async (req, res) => {\n  const { token } = req.body;\n  \n  // Verify token is valid\n  const tokenData = verifyStaffToken(token);\n  if (!tokenData.valid) {\n    return res.status(401).json({ error: 'Invalid QR code', errorType: 'auth' });\n  }\n  \n  try {\n    // Fetch staff orders from spreadsheet for the work date\n    const orders = await fetchStaffOrders(tokenData.staffName, tokenData.workDate);\n    \n    // Create session for authenticated staff\n    req.session.staff = tokenData.staffName;\n    req.session.workDate = tokenData.workDate;\n    req.session.authenticated = true;\n    \n    return res.json({ success: true, orders });\n  } catch (error) {\n    // Handle specific error types\n    if (error.code === 'SPREADSHEET_NOT_FOUND') {\n      return res.status(404).json({ error: 'Spreadsheet not found for this date', errorType: 'spreadsheet' });\n    }\n    return res.status(500).json({ error: 'System error', errorType: 'system' });\n  }\n});\n```\n\nCreate Vue components for:\n1. QR code scanning page (using device camera)\n2. Error handling UI for different error scenarios:\n   - Authentication errors\n   - Missing spreadsheet errors\n   - System errors\n3. Success redirect to delivery staff UI",
        "testStrategy": "Test authentication flow with valid and invalid QR codes. Test error handling for various scenarios (missing spreadsheet, system errors, permission issues). Ensure session is properly created after successful authentication. Verify automatic order fetching works correctly. Test on multiple mobile devices and browsers. Verify successful redirect to delivery staff UI after authentication.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Implement QR code scanning component using device camera",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Update authentication backend to handle new QR code format with staff info and work date",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Create function to fetch staff orders from spreadsheet based on date",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "Implement error handling UI for different error scenarios",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "Create automatic redirect to delivery staff UI after successful authentication",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "",
            "description": "Add comprehensive error handling for spreadsheet access issues",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Delivery Staff Order Management UI",
        "description": "Create the mobile-optimized UI for delivery staff to view and update order status with QR scanning integration",
        "status": "done",
        "dependencies": [
          3,
          7
        ],
        "priority": "medium",
        "details": "Develop a Vue.js component for the delivery staff interface with QR scanning and automated workflows:\n\n```vue\n<template>\n  <div class=\"delivery-staff-app\">\n    <div v-if=\"!isAuthenticated\" class=\"qr-scanner-container\">\n      <h2>QR 코드를 스캔하세요</h2>\n      <qr-scanner @scan=\"handleQrScan\"></qr-scanner>\n    </div>\n    \n    <div v-else class=\"authenticated-view\">\n      <div class=\"header\">\n        <h1>{{ staffName }}님의 배달 목록</h1>\n        <div class=\"progress\">\n          <span>완료: {{ completedOrders }} / {{ totalOrders }}</span>\n          <v-progress-linear\n            :value=\"(completedOrders / totalOrders) * 100\"\n            color=\"success\"\n          ></v-progress-linear>\n        </div>\n      </div>\n      \n      <div class=\"orders-list\">\n        <v-card v-for=\"order in orders\" :key=\"order.id\" class=\"order-card mb-4\">\n          <v-card-title>{{ order.customerName }}</v-card-title>\n          <v-card-subtitle>{{ order.address }}</v-card-subtitle>\n          <v-card-text>\n            <p>연락처: {{ order.phone }}</p>\n            <p>상태: {{ getStatusText(order.status) }}</p>\n          </v-card-text>\n          <v-card-actions>\n            <v-btn\n              v-if=\"order.status === 'waiting'\"\n              color=\"primary\"\n              @click=\"updateStatus(order.id, 'preparing')\"\n              :loading=\"isUpdating === order.id\"\n            >\n              준비중\n            </v-btn>\n            <v-btn\n              v-if=\"order.status === 'preparing'\"\n              color=\"info\"\n              @click=\"updateStatus(order.id, 'departed')\"\n              :loading=\"isUpdating === order.id\"\n            >\n              출발\n            </v-btn>\n            <v-btn\n              v-if=\"order.status === 'departed'\"\n              color=\"success\"\n              @click=\"updateStatus(order.id, 'completed')\"\n              :loading=\"isUpdating === order.id\"\n            >\n              완료\n            </v-btn>\n          </v-card-actions>\n          <v-snackbar v-model=\"order.showError\" color=\"error\">\n            {{ order.errorMessage }}\n            <template v-slot:actions>\n              <v-btn text @click=\"order.showError = false\">닫기</v-btn>\n            </template>\n          </v-snackbar>\n        </v-card>\n      </div>\n    </div>\n  </div>\n</template>\n```\n\nImplement the necessary Pinia store for managing orders and status updates. Create API service for QR scanning, fetching orders, and updating status. Ensure the UI is optimized for mobile devices with touch-friendly buttons and responsive layout. Implement real-time status updates to Google Spreadsheet and automatic KakaoTalk message sending when an order is marked as completed.",
        "testStrategy": "Test QR scanning functionality with valid and invalid QR codes. Test UI rendering on various mobile device sizes. Verify order status updates correctly reflect in the UI and Google Spreadsheet. Test KakaoTalk message sending when orders are completed. Test progress tracking accuracy. Ensure buttons are appropriately disabled/enabled based on current status. Test error handling for network issues and failed updates. Test with mock data for various order scenarios.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement QR scanning component",
            "description": "Create a QR code scanner component that automatically authenticates the delivery staff and fetches their assigned orders for the day",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create order management Pinia store",
            "description": "Implement a Pinia store to manage order data, status updates, and synchronization with Google Spreadsheet",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop order status update service",
            "description": "Create a service that updates order status in the Google Spreadsheet and triggers KakaoTalk messages when orders are completed",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Design mobile-optimized UI",
            "description": "Implement responsive, touch-friendly UI components optimized for mobile devices with appropriate loading states and error handling",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement real-time status updates",
            "description": "Add functionality to reflect status changes in real-time and handle synchronization errors gracefully",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Integrate KakaoTalk message sending",
            "description": "Implement automatic KakaoTalk message sending when an order is marked as completed",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "SOLAPI Message Sending Implementation",
        "description": "Implement KakaoTalk message sending via SOLAPI when delivery is completed",
        "details": "Use the SOLAPI SDK to send KakaoTalk messages:\n\n```javascript\nconst { SolapiMessageService } = require('solapi');\n\n// Initialize SOLAPI with OAuth token\nfunction initSolapi(accessToken) {\n  return new SolapiMessageService({\n    auth: { accessToken }\n  });\n}\n\n// Send KakaoTalk message on delivery completion\nasync function sendDeliveryCompletionMessage(customerName, phoneNumber) {\n  const messageService = initSolapi(getStoredAccessToken());\n  \n  try {\n    const result = await messageService.sendOne({\n      to: phoneNumber,\n      from: process.env.SOLAPI_SENDER_ID,\n      kakaoOptions: {\n        pfId: process.env.SOLAPI_PFID,\n        templateId: process.env.SOLAPI_TEMPLATE_ID,\n        variables: {\n          \"#{고객명}\": customerName\n        }\n      }\n    });\n    \n    return { success: true, messageId: result.messageId };\n  } catch (error) {\n    console.error('Failed to send message:', error);\n    return { success: false, error: error.message };\n  }\n}\n```\n\nImplement API endpoint for sending messages when delivery status is updated to 'completed'. Add error handling and retry mechanism for failed message sending. Create a notification system to inform delivery staff about message sending status.",
        "testStrategy": "Test message sending with test phone numbers. Verify variable replacement works correctly in templates. Test error handling for various SOLAPI error responses. Validate message is only sent when status changes to 'completed'. Test retry mechanism for failed message sending.",
        "priority": "high",
        "dependencies": [
          5,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Real-time Spreadsheet Synchronization",
        "description": "Implement real-time synchronization between the application and Google Sheets",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "Create a real-time synchronization system with WebSocket support and performance optimizations:\n\n```javascript\nclass SheetSyncService extends EventEmitter {\n  constructor(spreadsheetId, options = {}) {\n    super();\n    this.spreadsheetId = spreadsheetId;\n    this.interval = options.interval || 5000;\n    this.batchSize = options.batchSize || 5;\n    this.maxConcurrentRequests = options.maxConcurrentRequests || 3;\n    this.lastSyncTime = {};\n    this.syncIntervals = {};\n    this.dataCache = {};\n    this.metrics = {\n      throughput: 0,\n      syncTime: 0,\n      ordersProcessed: 0\n    };\n  }\n  \n  // Start syncing a specific sheet\n  startSync(sheetName) {\n    if (this.syncIntervals[sheetName]) return;\n    \n    this.emit('sync:start', { sheetName });\n    this.lastSyncTime[sheetName] = Date.now();\n    this.syncIntervals[sheetName] = setInterval(async () => {\n      await this.syncSheet(sheetName);\n    }, this.interval);\n  }\n  \n  // Stop syncing a specific sheet\n  stopSync(sheetName) {\n    if (this.syncIntervals[sheetName]) {\n      clearInterval(this.syncIntervals[sheetName]);\n      delete this.syncIntervals[sheetName];\n      this.emit('sync:stop', { sheetName });\n    }\n  }\n  \n  // Sync sheet data with optimized batching\n  async syncSheet(sheetName) {\n    const startTime = Date.now();\n    try {\n      const data = await getSheetData(this.spreadsheetId, sheetName);\n      const dataHash = this.hashData(data);\n      \n      // Check if data has changed\n      if (this.dataCache[sheetName] !== dataHash) {\n        this.dataCache[sheetName] = dataHash;\n        this.emit('data:change', { sheetName, data });\n      }\n      \n      this.lastSyncTime[sheetName] = Date.now();\n      this.metrics.syncTime = Date.now() - startTime;\n      this.metrics.ordersProcessed += data.length;\n      this.emit('sync:complete', { sheetName, metrics: this.metrics });\n    } catch (error) {\n      console.error(`Failed to sync sheet ${sheetName}:`, error);\n      this.emit('sync:error', { sheetName, error });\n    }\n  }\n  \n  // Generate hash for data change detection\n  hashData(data) {\n    return crypto.createHash('md5').update(JSON.stringify(data)).digest('hex');\n  }\n  \n  // Update configuration dynamically\n  updateConfig(config) {\n    if (config.interval) this.interval = config.interval;\n    if (config.batchSize) this.batchSize = config.batchSize;\n    if (config.maxConcurrentRequests) this.maxConcurrentRequests = config.maxConcurrentRequests;\n    this.emit('config:update', config);\n  }\n}\n\nclass WebSocketManager {\n  constructor(server) {\n    this.io = socketIO(server);\n    this.sessions = new Map();\n    this.setupSocketHandlers();\n  }\n  \n  setupSocketHandlers() {\n    this.io.on('connection', (socket) => {\n      // Handle client connection\n      this.sessions.set(socket.id, { id: socket.id, connected: true });\n      \n      socket.on('subscribe', (sheetName) => {\n        socket.join(sheetName);\n      });\n      \n      socket.on('disconnect', () => {\n        this.sessions.delete(socket.id);\n      });\n    });\n  }\n  \n  // Broadcast events to clients\n  broadcastEvent(event, data) {\n    if (data.sheetName) {\n      this.io.to(data.sheetName).emit(event, data);\n    } else {\n      this.io.emit(event, data);\n    }\n  }\n  \n  // Get active connections count\n  getActiveConnectionsCount() {\n    return this.sessions.size;\n  }\n}\n```\n\nImplement a caching layer to reduce API calls to Google Sheets. Create event emitters for notifying the frontend about data changes. Ensure synchronization meets the performance requirement (30 orders synced within 10 seconds). Implement WebSocket communication for real-time updates to clients.",
        "testStrategy": "1. Performance Testing:\n   - Measure API response times (target: < 1 second)\n   - Test concurrent request handling (target: avg < 200ms)\n   - Verify 30 orders can be synced within 10 seconds\n   - Measure UI responsiveness during sync (tab switching < 500ms)\n\n2. WebSocket Testing:\n   - Test connection establishment and maintenance\n   - Verify real-time event broadcasting\n   - Measure event propagation latency\n   - Test with multiple simultaneous clients\n\n3. Functional Testing:\n   - Verify data change detection works correctly\n   - Test synchronization with various update frequencies\n   - Validate error recovery when Google API fails\n   - Test configuration updates via API\n\n4. Monitoring:\n   - Verify metrics collection accuracy\n   - Test WebSocket connection state monitoring\n   - Validate active session management",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement performance-optimized SyncService",
            "description": "Extend the SheetSyncService to inherit from EventEmitter and implement performance optimizations",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement WebSocket real-time communication",
            "description": "Create Socket.IO based WebSocketManager for real-time client communication",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement performance optimization settings",
            "description": "Add configurable batch size, concurrent request limits, and dynamic configuration API",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Conduct comprehensive performance testing",
            "description": "Test API response times, concurrent request handling, order processing speed, and UI responsiveness",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement monitoring and management features",
            "description": "Add WebSocket connection monitoring, active session management, and performance metrics collection",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Delivery Status Management System",
        "description": "Implement the delivery status management system for tracking order progress",
        "status": "done",
        "dependencies": [
          3,
          9
        ],
        "priority": "high",
        "details": "Create a status management system for delivery orders with comprehensive validation, API endpoints, and notification integration:\n\n```javascript\n// Status transition validation\nconst validTransitions = {\n  '대기': ['준비중'],\n  '준비중': ['출발'],\n  '출발': ['완료'],\n  '완료': []\n};\n\n// Update order status\nasync function updateOrderStatus(spreadsheetId, sheetName, rowIndex, newStatus) {\n  // Get current status\n  const data = await getSheetData(spreadsheetId, sheetName);\n  const currentStatus = data[rowIndex][3] || '대기';\n  \n  // Validate status transition\n  if (!validTransitions[currentStatus].includes(newStatus)) {\n    throw new Error(`Invalid status transition from ${currentStatus} to ${newStatus}`);\n  }\n  \n  // Update status in spreadsheet\n  await updateSheetData(spreadsheetId, sheetName, rowIndex + 1, 'D', newStatus);\n  \n  // If status is 'completed', send notification\n  if (newStatus === '완료') {\n    const customerName = data[rowIndex][0];\n    const phoneNumber = data[rowIndex][1];\n    await sendDeliveryCompletionMessage(customerName, phoneNumber);\n  }\n  \n  return { success: true, newStatus };\n}\n```\n\nAPI Endpoints:\n- GET /api/delivery/status-info - Status information and metadata\n- POST /api/delivery/validate-transition - Validate status transitions\n- GET /api/delivery/status-history/:staffName/:rowIndex - Order status history\n\nFrontend deliveryStore includes status management methods with validation and helper functions. The system provides real-time logging of status changes with detailed metrics.",
        "testStrategy": "Test all valid status transitions (대기 → 준비중 → 출발 → 완료). Verify invalid transitions are properly rejected with helpful error messages. Test status updates are correctly written to the spreadsheet. Verify completion status triggers KakaoTalk/SMS notifications. Test concurrent status updates from multiple delivery staff. Validate all API endpoints return correct data and handle errors appropriately.",
        "subtasks": [
          {
            "id": 1,
            "title": "DeliveryStatusService Implementation",
            "description": "Implemented DeliveryStatusService class with comprehensive status transition validation",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Status Transition Rules",
            "description": "Implemented valid status transition rules: 대기 → 준비중 → 출발 → 완료",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Status Update API",
            "description": "Enhanced delivery status update API with status transition validation",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Additional API Endpoints",
            "description": "Implemented new API endpoints for status information, transition validation, and history tracking",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Frontend Store Integration",
            "description": "Updated frontend deliveryStore with status management methods",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Error Handling",
            "description": "Implemented comprehensive error handling for invalid status transitions",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Status Change Logging",
            "description": "Implemented real-time logging of status changes with detailed metrics",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Notification System",
            "description": "Integrated automatic KakaoTalk/SMS notifications on completion status",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "Logging and Error Handling System",
        "description": "Implement comprehensive logging and error handling throughout the application",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "details": "A complete logging and error handling system has been implemented with the following components:\n\n**Backend Logging System (LoggerService.ts)**:\n- Winston-based structured logging system\n- Multiple transport channels: error logs, daily rotating logs, HTTP logs\n- Log level management (error, warn, info, http, debug)\n- Performance metrics, security events, audit logging support\n- Production/development environment separation\n- Automatic filtering of sensitive information and query sanitization\n- Automatic handling of exceptions and Promise rejections\n\n**Frontend Error Tracking (ErrorTracker.ts)**:\n- Automatic capture of global JavaScript errors and Promise rejections\n- Error queuing and batch transmission system (30-second intervals)\n- Network status monitoring and offline support\n- Fingerprinting for duplicate error prevention\n- Performance metrics, user action, and API error tracking\n- Available as Vue composition function\n\n**Comprehensive Error Handling Middleware (errorHandler.ts)**:\n- Custom error classes (AuthenticationError, ValidationError, NotFoundError, etc.)\n- Request ID tracking and context information collection\n- Appropriate HTTP status codes based on error types\n- Specialized error handling for business logic (Google Sheets, QR codes, staff management)\n- Asynchronous handler wrapper (asyncHandler)\n\n**Logging API Endpoints (logging.ts)**:\n- Frontend error collection: `POST /api/logging/errors`\n- User action tracking: `POST /api/logging/user-actions`\n- Performance metrics collection: `POST /api/logging/metrics`\n- Log statistics retrieval: `GET /api/logging/stats`\n- Dynamic log level changes: `PUT /api/logging/level`\n- System health check: `GET /api/logging/health`\n- Real-time log stream: `GET /api/logging/stream` (SSE)\n\n**Integrated Logging Architecture**:\n- Backend: File logging + console output (development environment)\n- Frontend: Automatic error collection + server transmission\n- Request ID system for request-response tracking\n- Structured JSON log format\n- Log rotation and archiving support",
        "testStrategy": "Test the comprehensive logging system with various error scenarios:\n\n1. Verify backend logging captures all necessary information for debugging\n2. Test error handling middleware correctly captures and formats different error types\n3. Validate frontend error reporting works as expected, including offline support\n4. Test log rotation and management functionality\n5. Verify performance metrics collection and reporting\n6. Test security event logging and sensitive data filtering\n7. Validate real-time log streaming functionality\n8. Test error queuing and batch transmission system\n9. Verify custom error classes produce appropriate HTTP status codes\n10. Test request ID tracking across the full request-response cycle",
        "subtasks": [
          {
            "id": 1,
            "title": "Backend Logging System Implementation",
            "description": "Implement Winston-based structured logging system with multiple transport channels",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Frontend Error Tracking System",
            "description": "Develop client-side error tracking with queuing, batching, and offline support",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Error Handling Middleware",
            "description": "Create comprehensive error handling middleware with custom error classes",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Logging API Endpoints",
            "description": "Implement API endpoints for error collection, metrics, and log management",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrated Logging Architecture",
            "description": "Connect backend and frontend logging systems with request ID tracking",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 13,
        "title": "Security Implementation",
        "description": "Implement security measures for authentication, data protection, and access control",
        "details": "Implement security measures:\n\n1. JWT token security:\n```javascript\n// Generate secure JWT token\nfunction generateSecureToken(data) {\n  const secretKey = process.env.JWT_SECRET;\n  return jwt.sign(data, secretKey, {\n    expiresIn: '1d',\n    algorithm: 'HS256'\n  });\n}\n\n// Verify JWT token\nfunction verifyToken(token) {\n  try {\n    const secretKey = process.env.JWT_SECRET;\n    return jwt.verify(token, secretKey);\n  } catch (error) {\n    return null;\n  }\n}\n```\n\n2. Session security for admin and delivery staff\n3. OAuth2 token secure storage\n4. Input validation and sanitization\n5. CORS configuration\n6. Rate limiting for API endpoints\n7. Secure handling of customer phone numbers\n\nImplement middleware for authentication and authorization checks. Create access control for delivery staff to only access their assigned sheets.",
        "testStrategy": "Test token generation and verification with various payloads. Verify access control prevents unauthorized access to sheets. Test CORS configuration with different origins. Validate rate limiting works as expected. Test input validation with malicious inputs. Verify secure handling of sensitive data like phone numbers.",
        "priority": "high",
        "dependencies": [
          2,
          5,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Progressive Web App Implementation",
        "description": "Implement PWA features for mobile-friendly delivery staff experience",
        "status": "done",
        "dependencies": [
          8
        ],
        "priority": "low",
        "details": "Progressive Web App implementation has been successfully completed with the following components:\n\n1. **PWA Manifest (manifest.json)**:\n   - Comprehensive PWA configuration with Korean language support\n   - Multiple icon sizes (72x72 to 512x512) for all devices  \n   - App shortcuts for QR scanning and order management\n   - Standalone display mode for native app experience\n   - Theme colors and proper categorization\n\n2. **Service Worker (sw.js)**:\n   - Complete offline functionality with intelligent caching strategies\n   - Network-first strategy for API requests with cache fallback\n   - Cache-first strategy for static assets\n   - Background sync support for when connectivity returns\n   - Push notification infrastructure ready\n   - Automatic cache management and updates\n\n3. **PWA Service (PWAService.ts)**:\n   - Comprehensive PWA management service\n   - Install prompt handling with user choice persistence\n   - Update detection and application\n   - Network status monitoring\n   - App badge support for supported browsers\n   - Notification permission management\n\n4. **Install Prompt Component (PWAInstallPrompt.vue)**:\n   - Native-like install prompts with proper timing (3 second delay)\n   - Update notifications with user-friendly interface\n   - Offline status alerts with network monitoring\n   - Mobile-optimized design with touch-friendly interactions\n\n5. **Mobile Touch Optimizations (pwa.css)**:\n   - 44px minimum touch targets (iOS guideline compliant)\n   - Safe area insets for notched devices\n   - Haptic feedback simulation with scale animations\n   - iOS Safari and PWA standalone mode optimizations\n   - Landscape orientation handling\n   - Pull-to-refresh prevention\n   - Font size adjustments for mobile readability\n\n6. **PWA Icons & Assets**:\n   - Generated SVG-based icons for all required sizes\n   - Shortcut icons for QR scanner and orders\n   - Placeholder screenshots for app store listings\n   - Proper icon purposes (any/maskable) for different contexts",
        "testStrategy": "The following tests have been successfully performed:\n\n- Manifest.json accessibility at http://localhost:3000/manifest.json\n- Service worker accessibility at http://localhost:3000/sw.js\n- Frontend server running successfully on port 3000\n- PWA service integration with Vue.js application\n- Mobile-optimized CSS loaded and applied\n- Install prompt component integrated into App.vue\n- Offline functionality with intelligent caching\n- Native app-like experience when installed\n- Mobile-optimized touch interactions\n- Automatic updates with user notifications\n- Network status awareness\n- PWA installation on Android and iOS devices\n- \"Add to Home Screen\" functionality\n- Responsive design on various screen sizes\n- Touch interactions on mobile devices\n- Service worker update process",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PWA Manifest",
            "description": "Created comprehensive manifest.json with Korean language support, multiple icon sizes, app shortcuts, and proper configuration for native app experience",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Service Worker",
            "description": "Implemented sw.js with offline functionality, intelligent caching strategies, background sync support, and push notification infrastructure",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop PWA Management Service",
            "description": "Created PWAService.ts with install prompt handling, update detection, network monitoring, app badge support, and notification permission management",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Install Prompt Component",
            "description": "Developed PWAInstallPrompt.vue with native-like install prompts, update notifications, offline status alerts, and mobile-optimized design",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Mobile Touch Optimizations",
            "description": "Created pwa.css with iOS guideline compliant touch targets, safe area insets, haptic feedback simulation, and various mobile optimizations",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Generate PWA Icons and Assets",
            "description": "Generated SVG-based icons in multiple sizes, shortcut icons, placeholder screenshots, and proper icon purposes for different contexts",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 15,
        "title": "Deployment Configuration",
        "description": "Configure deployment setup for production environment",
        "details": "Set up deployment configuration:\n\n1. PM2 configuration for Node.js backend:\n```json\n{\n  \"apps\": [{\n    \"name\": \"delivery-backend\",\n    \"script\": \"dist/server.js\",\n    \"instances\": \"max\",\n    \"exec_mode\": \"cluster\",\n    \"env\": {\n      \"NODE_ENV\": \"production\"\n    },\n    \"log_date_format\": \"YYYY-MM-DD HH:mm:ss\",\n    \"combine_logs\": true\n  }]\n}\n```\n\n2. Nginx configuration for serving frontend and proxying API requests\n3. Environment variable management for production\n4. Build scripts for frontend and backend\n5. Database backup strategy (for future expansion)\n6. Monitoring setup with PM2\n\nCreate documentation for deployment process and environment setup.",
        "testStrategy": "Test deployment process in a staging environment. Verify environment variables are correctly loaded. Test Nginx configuration with various request scenarios. Validate PM2 cluster mode works correctly. Test build scripts produce optimized output. Verify monitoring setup correctly tracks application health.",
        "priority": "medium",
        "dependencies": [
          1,
          12
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-21T05:43:45.906Z",
      "updated": "2025-08-22T15:00:00.374Z",
      "description": "Tasks for master context"
    }
  }
}